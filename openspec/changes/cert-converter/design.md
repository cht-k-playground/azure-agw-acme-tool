## Context

The `cert-converter` module sits between the ACME client (which produces PEM-encoded certificates and keys) and the Azure Gateway client (which consumes PFX-encoded data). It also supports the `status` command by exposing expiry-date extraction and SHA-256 fingerprinting. All cryptographic operations use the `cryptography` library (already declared in `pyproject.toml`), keeping private key material exclusively in memory.

Current state: no such module exists. The `cli-issue`, `cli-renew`, `cli-status`, and `issue-flow-core` changes are all blocked on this module.

Constraints (from AGENTS.md):
- `mypy --strict` must pass on all public functions
- `ruff` lint must be clean
- `black --line-length 100` formatting
- ≥80% line coverage
- Private key material must never be written to disk or logged
- Custom exception classes per module

## Goals / Non-Goals

**Goals:**
- Provide `pem_to_pfx`, `cert_fingerprint`, `cert_expiry`, `generate_csr` as stable, typed, pure-in-memory functions
- Define `CertConverterError` as the module's structured exception
- Achieve ≥80% line coverage with `pytest` using self-signed test fixtures

**Non-Goals:**
- Certificate chain validation or trust store integration (out of scope for Phase 1)
- Key generation (callers provide the private key PEM)
- Disk I/O for keys or certificates (responsibility of callers)
- Support for certificate formats other than PEM input / PFX output

## Decisions

### D1: Use `cryptography` library directly (not `OpenSSL` bindings)

`cryptography` is already a declared dependency and provides a stable, high-level Pythonic API (`x509`, `serialization`, `hazmat.primitives`). The lower-level `pyOpenSSL` wrapper adds no value here and its type stubs are incomplete, creating `mypy --strict` friction.

**Alternative considered**: `pyOpenSSL` — rejected because it is a thin wrapper around the same `cryptography` backend with worse type coverage.

### D2: Random PFX password generated by caller, not by `pem_to_pfx`

`pem_to_pfx` accepts a `password: str` parameter. The caller (`issue-flow-core`) generates the random password using `secrets.token_hex(32)` and keeps it in memory. This keeps the function pure (no side effects, deterministic given the same inputs) and easier to test.

**Alternative considered**: Generating the random password inside `pem_to_pfx` and returning `(pfx_bytes, password)` — rejected because it couples randomness to the converter and complicates the call site.

### D3: `generate_csr` returns DER bytes, not PEM string

The `acme` library's `finalize_order` call expects a DER-encoded CSR. Returning DER directly avoids a needless encode/decode round-trip at the call site. Callers that need PEM can encode with `base64` themselves.

### D4: `cert_expiry` returns timezone-aware UTC `datetime`

`not_valid_after_utc` (available in `cryptography>=42`) returns a timezone-aware `datetime`. For `cryptography<42` compatibility the fallback is `not_valid_after` (naive) converted with `.replace(tzinfo=timezone.utc)`. The returned value is always UTC-aware to avoid ambiguity in renewal-window comparisons.

### D5: Module structure — single flat file `cert_converter.py`

All four functions are cohesive (same domain, no inter-function state) and small enough to live in one module without impeding readability. A sub-package would be premature.

## Risks / Trade-offs

- **`cryptography` version drift** → `not_valid_after_utc` was added in v42; we guard with `hasattr` and fall back to `not_valid_after + replace(tzinfo=utc)`. Risk is low because `pyproject.toml` pins `>=41.0` and the fallback is straightforward.
- **PFX password in memory** → password is a Python `str`; CPython does not zero memory on deallocation, so the password lingers in the process heap briefly. This is acceptable for a CLI tool but noted as a known limitation.
- **CSR key algorithm** → `generate_csr` accepts any `key_pem` (RSA or EC). We do not validate the key type; invalid PEM will raise `CertConverterError` wrapping the underlying `ValueError`.

## Migration Plan

This is a new module with no prior state. No migration is required. The module is imported by downstream commands once they are implemented.
